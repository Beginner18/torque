#include <pbs_config.h>   /* the master config generated by configure */
#include "xml_recov.h"

#include "pbs_ifl.h"
#include <errno.h>
#include "log.h"
#include "../lib/Liblog/pbs_log.h"
#include "lib_ifl.h"
#include <string>


#ifndef PBS_MOM
/* parseResourcesValue
 * 
 * takes a xmlNodePtr to store the resource values in
 * and a string which is the values of the resource_default attribute
 *
 * content should look similar to this
 * "\t\t<walltime>300</walltime>\n\t\t<nodes>1</nodes>\n"
 * for any number of resource_defaults 
 *
 * called by que_save_attr_xml
*/
void parseResourcesValue(
    
  xmlNodePtr  &res_defaults,
  std::string  content)

  {
  
  while(content != "")
    {
          
    int find_less = content.find("<");
    content = content.substr(find_less+1);
    
    int find_greater = content.find(">");
    std::string name = content.substr(0,find_greater);
    
    content = content.substr(name.size()+1);
    
    find_less = content.find("<");
    std::string value = content.substr(0,find_less);
    
    int find_close = content.find(name);
    content = content.substr(find_close+name.size());
    if (content.find("<") == std::string::npos)
      {
      content = "";
      }
   
    xmlNewChild(res_defaults, NULL, BAD_CAST name.c_str(),BAD_CAST value.c_str());

     }
  }



/* que_save_attr_xml
 * 
 * stores the que attributes into a libxml2 NodePtr
 * which is used in que_save() to write out to disk
 *
*/
int save_attr_xml(
 
  struct attribute_def *padef,   /* pbs_attribute definition array */
  pbs_attribute        *pattr,   /* ptr to pbs_attribute value array */
  int                   numattr, /* number of attributes in array */
  xmlNodePtr            node_tree)    /* xml node attributes to fill*/  
  {
  int             i;
  int             rc = PBSE_NONE;
  char            log_buf[LOCAL_LOG_BUF_SIZE];
  std::string     attr_string = "";


  xmlNodePtr node = NULL;
  for (node = node_tree->xmlChildrenNode; node != NULL;node = node->next)
    {
    if(!xmlStrcmp(node->name, BAD_CAST "attributes"))
      {
      break;
      }
    }

  if (node == NULL)
    return(-1);

  for (i = 0; i < numattr; i++)
    {
    if (pattr[i].at_flags & ATR_VFLAG_SET)
      {
      attr_string.clear();

      if ((rc = attr_to_str(attr_string, padef+i, pattr[i], true)) != 0)
        {
        if (rc != NO_ATTR_DATA)
          {
          /* ERROR */
          snprintf(log_buf,sizeof(log_buf),
              "Not enough space to print pbs_attribute %s",
              padef[i].at_name);

          return(rc);
          }
        }
      else
        {
        if (padef[i].at_type == ATR_TYPE_RESC)
          {
          xmlNewChild(node,NULL,BAD_CAST padef[i].at_name,NULL);
          xmlNodePtr res_defaults = node->last;
          parseResourcesValue(res_defaults,attr_string);
          }
        else if (attr_string == "" )
          {
          xmlNewChild(node, NULL, BAD_CAST padef[i].at_name, BAD_CAST "0");
          }
        else
          {
          xmlNewChild(node, NULL, BAD_CAST padef[i].at_name, BAD_CAST attr_string.c_str());
          }
        }
      }
    } /* END for each pbs_attribute */

  /* we can just return this since its the last write */
  return(rc);
  } /* END que_save_attr_xml() */

#endif /* ndef PBS_MOM */
